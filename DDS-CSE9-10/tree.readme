ðŸŒ³ Trees in Data Structures
ðŸ”¹ 1. Terminology

Tree â†’ A non-linear, hierarchical data structure consisting of nodes connected by edges.

Node â†’ Basic unit containing data.

Root â†’ Topmost node (no parent).

Parent â†’ Node that has one or more children.

Child â†’ Node derived from a parent.

Leaf (External Node) â†’ Node with no children.

Internal Node â†’ Node with at least one child.

Sibling â†’ Nodes having the same parent.

Degree of Node â†’ Number of children of a node.

Depth â†’ Distance from root to a node.

Height of Node â†’ Number of edges on the longest path from node to a leaf.

Height of Tree â†’ Height of root node.

ðŸ”¹ 2. Binary Trees

A Binary Tree is a tree where each node has at most two children:

Left child

Right child

âœ… Properties of Binary Trees

Maximum nodes at level i = 2^i

Maximum nodes in a tree of height h = (2^(h+1)) â€“ 1

Minimum height for n nodes = âŒˆlogâ‚‚(n+1)âŒ‰ â€“ 1

A binary tree with n nodes has exactly n+1 NULL links.

ðŸ”¹ 3. Representation of Binary Trees
(a) Array Representation

Nodes stored in level order.

For node at index i:

Left child â†’ 2i + 1

Right child â†’ 2i + 2

Parent â†’ (i - 1)/2

(b) Linked Representation

Each node has:

struct Node {
    int data;
    Node* left;
    Node* right;
};

ðŸ”¹ 4. Binary Tree Traversals

Traversal = visiting all nodes in some order.

Inorder (Left â†’ Root â†’ Right)

Example: Binary Search Tree â†’ gives sorted order.

inorder(node):
    if node == NULL: return
    inorder(node.left)
    print(node.data)
    inorder(node.right)


Preorder (Root â†’ Left â†’ Right)

Used to create copy of a tree.

preorder(node):
    if node == NULL: return
    print(node.data)
    preorder(node.left)
    preorder(node.right)


Postorder (Left â†’ Right â†’ Root)

Used in deleting a tree.

postorder(node):
    if node == NULL: return
    postorder(node.left)
    postorder(node.right)
    print(node.data)


ðŸ‘‰ Example Tree:

      A
     / \
    B   C
   / \
  D   E


Inorder: D B E A C

Preorder: A B D E C

Postorder: D E B C A

ðŸ”¹ 5. Additional Binary Tree Operations

Count nodes (recursive traversal).

Find height (longest path).

Find leaf nodes.

Mirror tree (swap left & right recursively).

Level-order traversal (BFS using queue).

ðŸ”¹ 6. Threaded Binary Trees

ðŸ‘‰ Motivation: In a binary tree, about 50% pointers are NULL.

Threaded Binary Tree replaces NULL pointers with links to inorder predecessor/successor.

Helps in fast inorder traversal without recursion or stack.

Types:

Left-threaded

Right-threaded

Fully threaded

ðŸ”¹ 7. Binary Search Tree (BST)

A BST is a binary tree with rules:

Left subtree values < root

Right subtree values > root

No duplicates

(a) Insertion
insert(root, key):
    if root == NULL:
        return newNode(key)
    if key < root.data:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

(b) Searching
search(root, key):
    if root == NULL or root.data == key:
        return root
    if key < root.data:
        return search(root.left, key)
    else:
        return search(root.right, key)

(c) Deletion

3 cases:

Node is leaf â†’ delete directly.

Node has one child â†’ replace node with child.

Node has two children â†’ replace with inorder successor (minimum in right subtree).

(d) Traversal

Same as binary tree (inorder, preorder, postorder).

Inorder traversal of BST gives sorted sequence.

ðŸ”¹ 8. Applications of Trees
(a) Expression Tree

Used in compilers to evaluate expressions.

Example: Expression â†’ (A + B) * (C - D)

        *
       / \
      +   -
     / \ / \
    A  B C  D


Inorder â†’ (A + B) * (C - D)

Preorder â†’ * + A B - C D

Postorder â†’ A B + C D - *

(b) Other Applications

Database indexing (B-Trees, B+ Trees)

File systems (directories as trees)

Network routing

Heaps (priority scheduling)

âœ… Summary

Tree â†’ hierarchical structure with root, parent, child, leaf.

Binary Tree â†’ max 2 children.

Properties â†’ height, depth, max nodes.

Representation â†’ array or linked.

Traversals â†’ Inorder, Preorder, Postorder.

Threaded Trees â†’ faster inorder without stack/recursion.

BST â†’ efficient searching, insertion, deletion.

Applications â†’ expression evaluation, databases, file systems.
